<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SWARM DEFENSE v2.1 - Fruit Fly Brain Satellite Control</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        input[type="range"],
        input[type="number"] {
            width: 100%;
            margin-top: 4px;
            background: #050505;
            color: #00ff00;
            border: 1px solid #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 10px;
        }
        input[type="range"] {
            accent-color: #00ff00;
            height: 16px;
        }
        .control-group {
            margin-bottom: 6px;
        }
        #game-container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        #legend {
            width: 380px;
            background: rgba(0, 0, 0, 0.95);
            color: #00ff00;
            padding: 12px;
            overflow-y: auto;
            border-right: 2px solid #00ff00;
            font-size: 10px;
            z-index: 100;
        }
        #legend h3 {
            color: #00ffff;
            margin: 8px 0 4px 0;
            font-size: 12px;
            border-bottom: 1px solid #00ffff;
        }
        #legend .key {
            margin: 3px 0;
            line-height: 1.2;
        }
        #legend .stat {
            color: #ffff00;
            font-weight: bold;
        }
        .section {
            margin-bottom: 10px;
        }
        .warning {
            color: #ff6600;
            font-weight: bold;
        }
        .danger {
            color: #ff0000;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        .quantum {
            color: #00ffff;
            font-weight: bold;
        }
        .brain {
            color: #ff00ff;
            font-weight: bold;
            text-shadow: 0 0 3px #ff00ff;
        }
        .gpu {
            color: #00ff00;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff00;
        }
        .swarm {
            color: #ffd700;
            font-weight: bold;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        #three-canvas {
            flex: 1;
        }
        #target-hud {
            position: absolute;
            top: 20px;
            right: 400px;
            color: #00ff00;
            font-size: 14px;
            text-shadow: 0 0 5px #00ff00;
            pointer-events: none;
        }
        .alert {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ff0000;
            text-shadow: 0 0 20px #ff0000;
            animation: pulse 0.5s infinite;
            pointer-events: none;
            display: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="legend">
            <h2 style="color: #ff6b6b; margin: 0 0 8px 0; font-size: 15px;">SWARM DEFENSE v2.1</h2>
            <div style="color: #888; font-size: 9px; margin-bottom: 10px;">
                <span class="brain" id="header-sat-count">50 SATS</span> |
                <span class="gpu" id="gpu-status">55 MW</span> | 
                <span class="quantum">2 AU DETECT</span>
            </div>
            
            <div style="color: #666; font-size: 8px; margin-bottom: 8px; font-style: italic;">
                Note: 1 game AU = 150,000 km (scaled)
            </div>
            
            <div class="section">
                <h3>CONTROLS</h3>
                <div class="key"><b>MOUSE</b> Rotate view</div>
                <div class="key"><b>WHEEL</b> Zoom</div>
                <div class="key"><b>SPACE</b> Auto-engage</div>
                <div class="key"><b>A</b> Toggle AI</div>
                <div class="key"><b>T</b> Target nearest</div>
                <div class="key"><b>D</b> Deploy swarm</div>
                <div class="key"><b>R</b> Reset simulation</div>
            </div>

            <div class="section">
                <h3>SWARM BRAIN STATUS</h3>
                <div class="key" id="ai-status">Mode: <span class="brain">AUTONOMOUS</span></div>
                <div class="key">CX Orient: <span id="cx-heading" class="brain">0¬∞</span></div>
                <div class="key">MB Threat: <span id="mb-valence" class="stat">0.0</span></div>
                <div class="key">Dopamine: <span id="dopamine" class="stat">0.0</span></div>
                <div class="key">AL Sensors: <span id="al-active" class="stat">0</span></div>
                <div class="key">Strategy: <span id="ai-strategy" class="brain">--</span></div>
                <div class="key">Decisions: <span id="decisions" class="stat">0</span></div>
            </div>

            <div class="section">
                <h3>MISSION STATUS</h3>
                <div class="key">Score: <span id="score-display" class="stat">0</span></div>
                <div class="key">High: <span id="high-score-display" class="stat">0</span></div>
                <div class="key">Multiplier: <span id="combo" class="stat">1√ó</span></div>
                <div class="key">Streak: <span id="combo-streak" class="stat">0</span></div>
                <div class="key">Mission Time: <span id="mission-time" class="stat">0:00</span></div>
                <div class="key">Deflections: <span id="deflections" class="stat">0</span></div>
                <div class="key">Earth Hits: <span id="earth-hits" class="danger">0</span></div>
                <div class="key">Wave: <span id="wave" class="stat">1</span></div>
            </div>

            <div class="section">
                <h3>SWARM COMPOSITION</h3>
                <div class="key">Active: <span id="sats-active" class="swarm">12</span></div>
                <div class="key">Formation: <span id="formation" class="stat">SPHERE</span></div>
                <div class="key">Coherence: <span id="coherence" class="stat">100</span>%</div>
                <div class="key">Power: <span id="power" class="stat">100</span>%</div>
            </div>

            <div class="section">
                <h3>RUNTIME CONFIG</h3>
                <div class="control-group">
                    <div class="key">Swarm Size Target: <span id="swarm-target" class="stat">50</span></div>
                    <input type="range" id="satellite-slider" min="10" max="200" step="10" value="50">
                </div>
                <div class="control-group">
                    <div class="key">Power Multiplier: <span id="power-multiplier" class="stat">1.0√ó</span></div>
                    <input type="range" id="power-slider" min="1" max="100" step="0.1" value="1">
                </div>
                <div class="control-group">
                    <div class="key">Time Scale: <span id="time-scale" class="stat">1.0√ó</span></div>
                    <input type="range" id="time-slider" min="0.1" max="20" step="0.1" value="1">
                </div>
                <div class="control-group">
                    <div class="key">Asteroid Mass Scale: <span id="asteroid-mass-scale" class="stat">1.0√ó</span></div>
                    <input type="range" id="mass-slider" min="0.1" max="5" step="0.1" value="1">
                </div>
            </div>

            <div class="section">
                <h3>SOLAR MIRRORS</h3>
                <div class="key">Power/Sat: <span class="swarm" id="power-per-sat">1.1</span> MW</div>
                <div class="key">Total Power: <span id="total-power" class="swarm">55</span> MW</div>
                <div class="key">Focus: <span id="focus-quality" class="stat">0.0</span></div>
                <div class="key">Convergence: <span id="convergence" class="stat">0</span>%</div>
                <div class="key">Intensity: <span id="intensity" class="stat">0.0</span> MW</div>
                <div class="key">Ablation: <span id="ablation-rate" class="stat">0.0</span> kg/s (equiv)</div>
            </div>

            <div class="section">
                <h3>TARGET TRACKING</h3>
                <div class="key">Asteroids: <span id="asteroid-count" class="warning">0</span></div>
                <div class="key">Locked: <span id="locked-target" class="stat">NONE</span></div>
                <div class="key">Distance: <span id="target-distance" class="stat">--</span></div>
                <div class="key">Velocity: <span id="target-velocity" class="stat">--</span></div>
                <div class="key">Œîv Required: <span id="delta-v" class="stat">--</span></div>
                <div class="key">Impact ETA: <span id="impact-eta" class="danger">--</span></div>
            </div>

            <div class="section">
                <h3>TECH UPGRADES</h3>
                <div class="key">Mirror Area: <span id="mirror-area" class="stat">1000</span> m¬≤</div>
                <div class="key">Swarm Size: <span id="max-sats" class="stat">50</span></div>
                <div class="key">Detection: <span id="detection-range" class="stat">2</span> AU</div>
                <div class="key">Engagement: <span id="engagement-range" class="stat">1</span> AU</div>
            </div>

            <div class="section">
                <h3>PHYSICS ENGINE</h3>
                <div class="key">Photon Flux: <span id="photon-flux" class="quantum">1.0</span></div>
                <div class="key">Ejecta ŒîV: <span id="ejecta-dv" class="quantum">0.0</span></div>
                <div class="key">Spall Rate: <span id="spall-rate" class="quantum">0.0</span></div>
                <div class="key">Modified Energy: <span id="modified-energy" class="quantum">0.0</span> EJ</div>
            </div>

            <div class="section">
                <h3>SPATIAL MEMORY</h3>
                <div class="key">Threats: <span id="mem-danger" class="stat">0</span></div>
                <div class="key">Trajectories: <span id="mem-visited" class="stat">0</span></div>
                <div class="key">Optimal Pos: <span id="mem-boundaries" class="stat">0</span></div>
            </div>
        </div>
        <div id="three-canvas"></div>
        <div id="target-hud"></div>
        <div id="alert" class="alert">‚ö† IMPACT IMMINENT ‚ö†</div>
    </div>
    
    <script>
        const DT = 1 / 60; // seconds per simulation step
        const G = 6.67430e-20; // km^3/(kg¬∑s^2)
        const BASE_BETA = 0.3; // coupling strength for Weyl twist
        const EARTH_MASS = 5.972e24; // kg
        const SUN_MASS = 5e23; // kg (scaled to keep system stable)
        const SATELLITE_MASS = 1200; // kg

        function formatMissionTime(seconds) {
            const totalSeconds = Math.max(0, Math.floor(seconds || 0));
            const minutes = Math.floor(totalSeconds / 60);
            const secs = totalSeconds % 60;
            const hours = Math.floor(minutes / 60);
            if (hours > 0) {
                const mins = minutes % 60;
                return `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        class ScaleField {
            constructor() {
                this.strength = 0.2;
                this.lengthScale = 60000; // km
            }

            sigma(position, t) {
                const r = position.length();
                return this.strength * Math.exp(-r / this.lengthScale) * Math.cos(0.0002 * t);
            }

            gradSigma(position, t) {
                const r = position.length();
                if (r < 1e-6) return new THREE.Vector3();
                const sigma = this.sigma(position, t);
                const radial = position.clone().multiplyScalar(1 / r);
                return radial.multiplyScalar(-sigma / this.lengthScale);
            }

            phi(position, t) {
                return Math.exp(this.sigma(position, t));
            }
        }

        function pairwiseForce(bi, bj, t, scale, beta) {
            const massI = bi.userData.mass || 0;
            const massJ = bj.userData.mass || 0;
            if (!massI || !massJ) return new THREE.Vector3();

            const r = new THREE.Vector3().subVectors(bj.position, bi.position);
            const distSq = Math.max(r.lengthSq(), 1e-6);
            const dist = Math.sqrt(distSq);
            const inv = 1 / dist;
            const inv3 = inv * inv * inv;

            const sigmaI = scale.sigma(bi.position, t);
            const gradSigma = scale.gradSigma(bi.position, t);
            const phiBeta = Math.exp(beta * sigmaI);

            const massProduct = G * massI * massJ;
            const newton = r.clone().multiplyScalar(massProduct * phiBeta * inv3);
            const coeff = -beta * massProduct * phiBeta * inv;
            const weyl = gradSigma.clone().multiplyScalar(coeff);

            return newton.add(weyl);
        }

        class PhysicsEngine {
            constructor() {
                this.scaleField = new ScaleField();
                this.bodies = [];
                this.time = 0;
                this.grades = [
                    { k: +1, c: 0.5 },
                    { k: -1, c: 0.5 }
                ];
            }

            registerBody(mesh, { mass, velocity = null, dynamic = true } = {}) {
                mesh.userData.mass = mass;
                mesh.userData.dynamic = dynamic;
                mesh.userData.velocity = velocity ? velocity.clone() : (mesh.userData.velocity || new THREE.Vector3());
                mesh.userData.accel = new THREE.Vector3();
                this.bodies.push(mesh);
            }

            deregisterBody(mesh) {
                const idx = this.bodies.indexOf(mesh);
                if (idx !== -1) {
                    this.bodies.splice(idx, 1);
                }
            }

            accumulateForces(t, beta) {
                for (const body of this.bodies) {
                    if (!body.userData.accel) body.userData.accel = new THREE.Vector3();
                    body.userData.accel.set(0, 0, 0);
                }

                for (let i = 0; i < this.bodies.length; i++) {
                    for (let j = i + 1; j < this.bodies.length; j++) {
                        const bi = this.bodies[i];
                        const bj = this.bodies[j];
                        const force = pairwiseForce(bi, bj, t, this.scaleField, beta);
                        if (force.lengthSq() === 0) continue;

                        if (bi.userData.dynamic !== false && bi.userData.mass) {
                            bi.userData.accel.addScaledVector(force, 1 / bi.userData.mass);
                        }
                        if (bj.userData.dynamic !== false && bj.userData.mass) {
                            bj.userData.accel.addScaledVector(force, -1 / bj.userData.mass);
                        }
                    }
                }
            }

            stepSystem(t, beta, dt) {
                for (const body of this.bodies) {
                    if (body.userData.dynamic === false || !body.userData.mass) continue;

                    body.userData.velocity.addScaledVector(body.userData.accel, 0.5 * dt);
                }

                for (const body of this.bodies) {
                    if (body.userData.dynamic === false || !body.userData.mass) continue;
                    body.position.addScaledVector(body.userData.velocity, dt);
                }

                this.accumulateForces(t + dt, beta);

                for (const body of this.bodies) {
                    if (body.userData.dynamic === false || !body.userData.mass) continue;
                    body.userData.velocity.addScaledVector(body.userData.accel, 0.5 * dt);
                }
            }

            integrate(dt) {
                let t = this.time;
                for (const { k, c } of this.grades) {
                    const slice = c * dt;
                    const beta = BASE_BETA * k;
                    this.accumulateForces(t, beta);
                    this.stepSystem(t, beta, slice);
                    t += slice;
                }
                this.time += dt;
            }

            computeModifiedEnergy() {
                let kinetic = 0;
                let potential = 0;
                let sigmaTerm = 0;
                const beta = BASE_BETA;
                for (const body of this.bodies) {
                    const m = body.userData.mass || 0;
                    if (!m) continue;
                    const v = body.userData.velocity ? body.userData.velocity.length() : 0;
                    kinetic += 0.5 * m * v * v;
                    sigmaTerm += beta * m * this.scaleField.sigma(body.position, this.time);
                }

                for (let i = 0; i < this.bodies.length; i++) {
                    for (let j = i + 1; j < this.bodies.length; j++) {
                        const bi = this.bodies[i];
                        const bj = this.bodies[j];
                        const mi = bi.userData.mass || 0;
                        const mj = bj.userData.mass || 0;
                        if (!mi || !mj) continue;
                        const r = new THREE.Vector3().subVectors(bj.position, bi.position);
                        const dist = Math.max(r.length(), 1e-6);
                        const sigmaAvg = 0.5 * (this.scaleField.sigma(bi.position, this.time) + this.scaleField.sigma(bj.position, this.time));
                        const phiBeta = Math.exp(beta * sigmaAvg);
                        potential += -G * mi * mj * phiBeta / dist;
                    }
                }

                return kinetic + potential + sigmaTerm;
            }
        }

        // ============================================================================
        // GPU-ACCELERATED FIL MANIFOLD - 100K CELLS (UNCHANGED)
        // ============================================================================
        
        class GPUFILManifold {
            constructor(n) {
                this.n = n;
                this.canvas = document.createElement('canvas');
                this.gl = this.canvas.getContext('webgl2');
                this.lastInputLength = 0;
                this.rhythmPhase = 0;

                if (!this.gl) {
                    console.warn('WebGL2 not available, falling back to CPU');
                    this.useCPU = true;
                    this.state = new Float32Array(n * 4);
                    this._initialize_golden();
                    return;
                }
                
                const ext = this.gl.getExtension('EXT_color_buffer_float');
                if (!ext) {
                    console.warn('EXT_color_buffer_float not available, falling back to CPU');
                    this.useCPU = true;
                    this.state = new Float32Array(n * 4);
                    this._initialize_golden();
                    return;
                }
                
                this.useCPU = false;
                this.textureSize = Math.ceil(Math.sqrt(n));
                
                this.stateTexture = this.createTexture();
                this.outputTexture = this.createTexture();
                this.framebuffer = this.gl.createFramebuffer();
                this.program = this.createShaderProgram();
                
                if (!this.program) {
                    console.warn('Shader compilation failed, falling back to CPU');
                    this.useCPU = true;
                    this.state = new Float32Array(n * 4);
                    this._initialize_golden();
                    return;
                }
                
                this.state = new Float32Array(n * 4);
                this._initialize_golden();
                
                // Pad to texture size to avoid undefined reads
                const texelCount = this.textureSize * this.textureSize;
                this.statePadded = new Float32Array(texelCount * 4);
                this.statePadded.set(this.state);
                
                this.uploadState();
            }

            createTexture() {
                const gl = this.gl;
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize, this.textureSize, 
                             0, gl.RGBA, gl.FLOAT, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                return texture;
            }
            
            createShaderProgram() {
                const gl = this.gl;
                
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, `#version 300 es
                    in vec2 position;
                    out vec2 texCoord;
                    void main() {
                        texCoord = position * 0.5 + 0.5;
                        gl_Position = vec4(position, 0.0, 1.0);
                    }
                `);
                gl.compileShader(vertexShader);
                
                if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                    console.error('Vertex shader compile error:', gl.getShaderInfoLog(vertexShader));
                    return null;
                }
                
                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, `#version 300 es
                    precision highp float;
                    in vec2 texCoord;
                    out vec4 outColor;
                    uniform sampler2D stateTexture;
                    
                    void main() {
                        vec4 state = texture(stateTexture, texCoord);
                        float p = state.x;
                        float q = state.y;
                        
                        // Hamiltonian evolution
                        float dp = -sin(q) * 0.05 - p * 0.02;
                        float dq = cos(p) * 0.05 - q * 0.02;
                        
                        p += dp;
                        q += dq;
                        
                        // Decay
                        p *= 0.98;
                        q *= 0.98;
                        
                        outColor = vec4(p, q, state.z, state.w);
                    }
                `);
                gl.compileShader(fragmentShader);
                
                if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                    console.error('Fragment shader compile error:', gl.getShaderInfoLog(fragmentShader));
                    return null;
                }
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Shader program link error:', gl.getProgramInfoLog(program));
                    return null;
                }
                
                // Create VAO for WebGL2 compatibility
                this.vao = gl.createVertexArray();
                
                return program;
            }
            
            _initialize_golden() {
                const phi = (1 + Math.sqrt(5)) / 2;
                const phi0 = 2 * Math.PI / phi;
                for (let i = 0; i < this.n; i++) {
                    this.state[i * 4] = Math.sin(phi0 * (i + 1)) * 0.1;
                    this.state[i * 4 + 1] = Math.cos(phi0 * (i + 1)) * 0.1;
                    this.state[i * 4 + 2] = 1.0;
                    this.state[i * 4 + 3] = 0.0;
                }
            }

            uploadState() {
                if (this.useCPU) return;
                const gl = this.gl;
                gl.bindTexture(gl.TEXTURE_2D, this.stateTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize, this.textureSize,
                             0, gl.RGBA, gl.FLOAT, this.statePadded);
            }

            evolveCPU() {
                for (let i = 0; i < this.n; i++) {
                    const base = i * 4;
                    const p = this.state[base];
                    const q = this.state[base + 1];
                    const dp = -Math.sin(q) * 0.05 - p * 0.02;
                    const dq = Math.cos(p) * 0.05 - q * 0.02;
                    this.state[base] = (p + dp) * 0.98;
                    this.state[base + 1] = (q + dq) * 0.98;
                }
            }

            runGPUPass() {
                if (this.useCPU) return;

                const gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
                                       gl.TEXTURE_2D, this.outputTexture, 0);

                const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                    console.error('Framebuffer incomplete, status:', status);
                    this.useCPU = true;
                    return;
                }

                gl.viewport(0, 0, this.textureSize, this.textureSize);
                gl.useProgram(this.program);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.stateTexture);
                gl.uniform1i(gl.getUniformLocation(this.program, 'stateTexture'), 0);

                gl.bindVertexArray(this.vao);
                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    -1, -1,  1, -1,  -1, 1,  1, 1
                ]), gl.STATIC_DRAW);

                const posLoc = gl.getAttribLocation(this.program, 'position');
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                [this.stateTexture, this.outputTexture] = [this.outputTexture, this.stateTexture];
            }

            evolve() {
                this.evolveCPU();

                if (!this.useCPU) {
                    this.statePadded.set(this.state);
                    this.uploadState();
                    this.runGPUPass();
                }
            }

            inject(inputs) {
                if (!inputs) return;
                const len = Math.min(inputs.length, this.n);
                this.lastInputLength = len;

                for (let i = 0; i < len; i++) {
                    const base = i * 4;
                    const drive = inputs[i] || 0;
                    this.state[base] = 0.94 * this.state[base] + 0.06 * drive;
                    const sign = drive >= 0 ? 1 : -1;
                    this.state[base + 1] = 0.94 * this.state[base + 1] + 0.03 * sign * Math.sqrt(Math.abs(drive));
                    this.state[base + 2] = drive;
                    this.state[base + 3] = this.state[base + 1];
                }
            }

            static clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }

            bandEnergy(start, length) {
                if (!Number.isFinite(start) || !Number.isFinite(length)) return 0;
                if (this.lastInputLength <= start) return 0;
                const span = Math.max(0, Math.min(length, this.lastInputLength - start));
                if (span <= 0) return 0;

                let sum = 0;
                for (let i = 0; i < span; i++) {
                    const base = (start + i) * 4;
                    const p = this.state[base];
                    const q = this.state[base + 1];
                    sum += Math.hypot(p, q);
                }

                return sum / span;
            }

            computeOrientationWeights(bands) {
                const { SPATIAL_START = 0, SPATIAL_LEN = 0, STATUS_START = 0 } = bands || {};
                if (SPATIAL_LEN <= 0) return [1, 1, 1, 1, 1, 1];

                const segments = 8;
                let x = 0;
                let y = 0;
                for (let s = 0; s < segments; s++) {
                    const segStart = SPATIAL_START + Math.floor((SPATIAL_LEN / segments) * s);
                    const segLen = Math.max(1, Math.floor(SPATIAL_LEN / segments));
                    const energy = this.bandEnergy(segStart, segLen);
                    const angle = (s / segments) * Math.PI * 2;
                    x += Math.cos(angle) * energy;
                    y += Math.sin(angle) * energy;
                }

                const statusUp = this.bandEnergy(STATUS_START, 2);
                const statusDown = this.bandEnergy(STATUS_START + 2, 2);

                const weights = [
                    GPUFILManifold.clamp(Math.max(0, x), 0.05, 5),
                    GPUFILManifold.clamp(Math.max(0, -x), 0.05, 5),
                    GPUFILManifold.clamp(Math.max(0, y), 0.05, 5),
                    GPUFILManifold.clamp(Math.max(0, -y), 0.05, 5),
                    GPUFILManifold.clamp(statusUp, 0.05, 5),
                    GPUFILManifold.clamp(statusDown, 0.05, 5)
                ];

                const maxVal = Math.max(...weights);
                if (maxVal <= 0) {
                    return [1, 1, 1, 1, 1, 1];
                }

                return weights.map(v => v / maxVal);
            }

            computeModulation(bands) {
                const spatialEnergy = this.bandEnergy(bands?.SPATIAL_START || 0, bands?.SPATIAL_LEN || 0);
                const threatEnergy = this.bandEnergy(bands?.THREAT_START || 0, bands?.THREAT_LEN || 0);
                const statusEnergy = this.bandEnergy(bands?.STATUS_START || 0, 4);

                this.rhythmPhase = (this.rhythmPhase + spatialEnergy * 0.15) % (Math.PI * 2);
                const rhythm = Math.sin(this.rhythmPhase);

                const cxGain = GPUFILManifold.clamp(0.8 + spatialEnergy * 0.9, 0.6, 1.8);
                const threatGate = GPUFILManifold.clamp(0.7 + threatEnergy * 1.8, 0.4, 2.5);
                const confidence = GPUFILManifold.clamp(0.8 + statusEnergy * 1.4, 0.5, 2.2);
                const caution = GPUFILManifold.clamp(0.7 + threatEnergy * 1.2, 0.4, 2.5);
                const mbTone = GPUFILManifold.clamp(0.9 + statusEnergy * 1.1, 0.5, 2.0);
                const orientationWeights = this.computeOrientationWeights(bands);

                const dopamineBias = GPUFILManifold.clamp((confidence - caution) * 0.35 + rhythm * 0.1, -0.4, 0.4);

                return {
                    cxGain,
                    threatGate,
                    confidence,
                    caution,
                    mbTone,
                    dopamineBias,
                    orientationWeights
                };
            }

            process(inputs, bands) {
                if (!(inputs instanceof Float32Array)) {
                    inputs = Float32Array.from(inputs || []);
                }

                this.inject(inputs);
                this.evolve();

                return this.computeModulation(bands);
            }
        }
        
        // ============================================================================
        // FRUIT FLY CIRCUIT MODULES (UNCHANGED)
        // ============================================================================
        
        class CXRing {
            constructor(M = 256) {
                this.M = M;
                this.r = new Float32Array(M);
                this.K = 4;
                
                this.W = {
                    center: 0.5,
                    exc: new Float32Array(this.K + 1),
                    inh: new Float32Array(this.K + 1)
                };
                
                for (let k = 1; k <= this.K; k++) {
                    this.W.exc[k] = 0.3 * Math.exp(-k * k / 4.0);
                    this.W.inh[k] = -0.15 * Math.exp(-k * k / 8.0);
                }
                
                this.wrapInh = 2;
            }
            
            step(inputBump, gain = 1.0) {
                const out = new Float32Array(this.M);
                
                for (let i = 0; i < this.M; i++) {
                    let s = this.W.center * this.r[i];
                    
                    for (let k = 1; k <= this.K; k++) {
                        const il = (i - k + this.M) % this.M;
                        const ir = (i + k) % this.M;
                        s += this.W.exc[k] * (this.r[il] + this.r[ir]);
                        
                        const iInhL = (i - k * this.wrapInh + this.M) % this.M;
                        const iInhR = (i + k * this.wrapInh) % this.M;
                        s += this.W.inh[k] * (this.r[iInhL] + this.r[iInhR]);
                    }
                    
                    out[i] = Math.max(0, 0.92 * this.r[i] + 0.08 * (s + gain * inputBump[i]));
                }
                
                this.r.set(out);
            }
            
            getHeading() {
                let maxIdx = 0;
                let maxVal = this.r[0];
                for (let i = 1; i < this.M; i++) {
                    if (this.r[i] > maxVal) {
                        maxVal = this.r[i];
                        maxIdx = i;
                    }
                }
                return maxIdx;
            }
            
            getHeadingAngle() {
                return (this.getHeading() / this.M) * 360;
            }
        }
        
        class MushroomBody {
            constructor(nKC = 2000, nMBON = 12) {
                this.nKC = nKC;
                this.nMBON = nMBON;
                
                this.KC = new Float32Array(nKC);
                this.KCthresh = 0.5;
                
                this.MBON = new Float32Array(nMBON);
                
                this.Wkm = new Float32Array(nKC * nMBON);
                
                for (let i = 0; i < this.Wkm.length; i++) {
                    this.Wkm[i] = (Math.random() - 0.5) * 0.1;
                }
                
                this.lrPos = 0.002;
                this.lrNeg = 0.002;
                this.decay = 0.9995;
            }
            
            forward() {
                this.MBON.fill(0);
                for (let k = 0; k < this.nKC; k++) {
                    if (this.KC[k] > this.KCthresh) {
                        for (let m = 0; m < this.nMBON; m++) {
                            this.MBON[m] += this.KC[k] * this.Wkm[k * this.nMBON + m];
                        }
                    }
                }
                
                for (let m = 0; m < this.nMBON; m++) {
                    this.MBON[m] = Math.max(0, Math.min(1, this.MBON[m]));
                }
            }
            
            learn(dopamine) {
                const lr = dopamine > 0 ? this.lrPos : this.lrNeg;
                const sign = dopamine > 0 ? 1 : -1;
                
                for (let k = 0; k < this.nKC; k++) {
                    if (this.KC[k] > this.KCthresh) {
                        for (let m = 0; m < this.nMBON; m++) {
                            const idx = k * this.nMBON + m;
                            this.Wkm[idx] += sign * lr * this.KC[k] * this.MBON[m] * Math.abs(dopamine);
                            
                            this.Wkm[idx] *= this.decay;
                            this.Wkm[idx] = Math.max(-0.5, Math.min(0.5, this.Wkm[idx]));
                        }
                    }
                }
            }
            
            getValence() {
                let approach = 0;
                let avoid = 0;
                for (let i = 0; i < 6; i++) approach += this.MBON[i];
                for (let i = 6; i < 12; i++) avoid += this.MBON[i];
                return { approach: approach / 6, avoid: avoid / 6 };
            }
        }
        
        class AntennalLobe {
            constructor(nGlom = 60) {
                this.nGlom = nGlom;
                this.r = new Float32Array(nGlom);
                this.W = new Float32Array(nGlom).fill(1.0);
                this.gInh = 0.3;
            }
            
            step(odorIn) {
                const mean = this.r.reduce((a, b) => a + b, 0) / this.nGlom;
                
                for (let i = 0; i < this.nGlom; i++) {
                    const drive = this.W[i] * (odorIn[i] || 0);
                    this.r[i] = Math.max(0, 0.9 * this.r[i] + 0.1 * (drive - this.gInh * mean));
                }
            }
            
            projectToKC(mb) {
                for (let k = 0; k < mb.nKC; k++) {
                    let sum = 0;
                    for (let s = 0; s < 6; s++) {
                        const g = Math.floor(Math.random() * this.nGlom);
                        sum += this.r[g];
                    }
                    mb.KC[k] = Math.tanh(sum / 6);
                }
            }
            
            getActiveGlomeruli() {
                let count = 0;
                for (let i = 0; i < this.nGlom; i++) {
                    if (this.r[i] > 0.1) count++;
                }
                return count;
            }
        }
        
        class LALGate {
            constructor() {
                this.ch = new Float32Array(6); // X+, X-, Y+, Y-, Z+, Z-
            }
            
            step(orientation, mbValence, threats) {
                const avoid = threats.approach * 3.0;
                const engage = mbValence.approach * 2.0;
                
                for (let i = 0; i < 6; i++) {
                    const axisSteer = orientation[i] || 0;
                    this.ch[i] = Math.max(0, 
                        0.85 * this.ch[i] + 
                        0.15 * (axisSteer * engage - avoid)
                    );
                }
                
                let maxIdx = 0;
                let maxVal = this.ch[0];
                for (let i = 1; i < 6; i++) {
                    if (this.ch[i] > maxVal) {
                        maxVal = this.ch[i];
                        maxIdx = i;
                    }
                }
                
                return ['X+', 'X-', 'Y+', 'Y-', 'Z+', 'Z-'][maxIdx];
            }
        }
        
        // ============================================================================
        // SWARM DEFENSE AGENT - Fruit Fly Brain Controlling Satellites
        // ============================================================================
        
        class SwarmDefenseAgent {
            constructor(game = null) {
                this.game = game;
                this.active = true;
                this.decisions = 0;
                this.tick = 0;
                this.currentStrategy = 'PATROL';

                // FIL manifold
                this.brain = new GPUFILManifold(100000);
                
                // Fly circuits
                this.cx = new CXRing(256);
                this.mb = new MushroomBody(2000, 12);
                this.al = new AntennalLobe(60);
                this.lal = new LALGate();
                
                // Sensory bands
                this.BANDS = {
                    SPATIAL_START: 0,
                    SPATIAL_LEN: 2048,
                    THREAT_START: 2560,
                    THREAT_LEN: 512,
                    STATUS_START: 3584
                };
                
                // Learning
                this._prevR = 0;
                this.dopamine = 0;
                
                // Memory
                this.threatMap = new Map();
                this.trajectoryMemory = new Map();
                this.optimalPositions = new Map();
                
                // Scoring
                this.score = 0;
                this.storageAvailable = typeof window !== 'undefined' && typeof window.localStorage !== 'undefined';
                this.highScore = 0;
                if (this.storageAvailable) {
                    const stored = window.localStorage.getItem('swarm_high_score');
                    const parsed = Number.parseInt(stored || '0', 10);
                    this.highScore = Number.isNaN(parsed) ? 0 : parsed;
                }
                this.deflections = 0;
                this.deflectionsInWave = 0;
                this.earthHits = 0;
                this.wave = 1;
                this.missionTime = 0;
                this.passiveScoreTimer = 0;
                this.comboTimer = 0;
                this.comboMultiplier = 1;
                this.comboStreak = 0;
                
                console.log('üõ∞Ô∏è SWARM DEFENSE initialized!', this.brain.useCPU ? 'CPU' : 'GPU');
                document.getElementById('gpu-status').textContent = this.brain.useCPU ? 'CPU: FALLBACK' : 'GPU: READY';
            }
            
            toggle() {
                this.active = !this.active;
                return this.active;
            }
            
            updateMemory(game) {
                // Track threats
                for (const [key, mem] of this.threatMap.entries()) {
                    mem.age++;
                    mem.threat *= 0.95;
                    if (mem.threat < 0.1 || mem.age > 100) {
                        this.threatMap.delete(key);
                    }
                }
                
                game.asteroids.forEach(ast => {
                    const key = `${ast.userData.id}`;
                    const threat = this.calculateThreatLevel(ast, game);
                    this.threatMap.set(key, { 
                        threat, 
                        age: 0, 
                        position: ast.position.clone(),
                        velocity: ast.userData.velocity.clone()
                    });
                });
            }
            
            calculateThreatLevel(asteroid, game) {
                const distToEarth = asteroid.position.distanceTo(game.earth.position);
                const velLength = asteroid.userData.velocity.length();
                const timeToImpact = velLength > 0 ? distToEarth / velLength : 9999;
                const size = asteroid.userData.radius;
                
                let threat = (size / 100) * 10; // Size factor
                threat += Math.max(0, 100 / (timeToImpact + 1)); // Urgency
                threat += Math.max(0, 50 / (distToEarth / 1000)); // Proximity
                
                return threat;
            }
            
            decide(game) {
                if (!this.active) return null;
                this.decisions++;
                this.tick++;
                
                this.updateMemory(game);
                
                if (this.tick % 50 === 0) {
                    console.log(`üß† SWARM: Threats=${this.threatMap.size}, Strategy=${this.currentStrategy}`);
                }
                
                const sensory = this.encodeSensory(game);
                const modulation = this.brain.process(sensory, this.BANDS) || {};

                // Check for urgent actions
                if (game.asteroids.length === 0) {
                    this.currentStrategy = 'PATROL';
                    return { type: 'PATROL' };
                }
                
                // Find highest threat
                const targetAsteroid = this.selectTarget(game);
                if (!targetAsteroid) {
                    this.currentStrategy = 'SEARCH';
                    return { type: 'SEARCH' };
                }
                
                // FRUIT FLY PROCESSING
                
                // 1. Antennal Lobe - threat sensing
                const threats = sensory.slice(this.BANDS.THREAT_START, this.BANDS.THREAT_START + this.BANDS.THREAT_LEN);
                if (modulation.threatGate) {
                    const gate = modulation.threatGate;
                    for (let i = 0; i < threats.length; i++) {
                        threats[i] *= gate;
                    }
                }
                this.al.step(threats);

                // 2. AL ‚Üí MB
                this.al.projectToKC(this.mb);

                // 3. MB forward + learning
                this.mb.forward();
                if (modulation.mbTone) {
                    const tone = modulation.mbTone;
                    for (let i = 0; i < this.mb.MBON.length; i++) {
                        this.mb.MBON[i] = Math.max(0, Math.min(1, this.mb.MBON[i] * tone));
                    }
                }
                const reward = this.computeReward(game, targetAsteroid);
                let dopamine = this.computeDopamine(reward);
                if (Number.isFinite(modulation.dopamineBias)) {
                    dopamine = Math.max(-1, Math.min(1, dopamine + modulation.dopamineBias));
                }
                if (Math.abs(dopamine) > 0.01) {
                    this.mb.learn(dopamine);
                }

                // 4. CX orientation
                const spatialBump = this.spatialToBump(sensory);
                this.cx.step(spatialBump, modulation.cxGain || 1.0);

                // 5. LAL action
                const mbValence = this.mb.getValence();
                if (modulation.confidence) {
                    mbValence.approach = Math.min(2, mbValence.approach * modulation.confidence);
                }
                if (modulation.caution) {
                    mbValence.avoid = Math.min(2, mbValence.avoid * modulation.caution);
                }
                const targetKey = `${targetAsteroid.userData.id}`;
                const targetThreat = this.threatMap.get(targetKey);
                const baseThreat = Math.min(1.0, (targetThreat?.threat || 0) / 10);
                const threatInfo = {
                    approach: Math.min(1.0, baseThreat * (modulation.threatGate || 1))
                };

                const orientation = this.computeSwarmOrientation(game, targetAsteroid);
                const orientationWeights = modulation.orientationWeights;
                const oriented = orientationWeights
                    ? orientation.map((value, idx) => value * orientationWeights[idx])
                    : orientation;
                const action = this.lal.step(oriented, mbValence, threatInfo);
                
                // Determine strategy based on 1 AU engagement window
                const distToTarget = targetAsteroid.position.distanceTo(new THREE.Vector3(0, 0, 0));
                
                // 1 AU = ~150,000 km (game units)
                if (distToTarget < 50000) {
                    this.currentStrategy = 'ENGAGE';
                    return { 
                        type: 'ENGAGE', 
                        target: targetAsteroid,
                        formation: 'FOCUS'
                    };
                } else if (distToTarget < 150000) { // Within 1 AU engagement window
                    this.currentStrategy = 'INTERCEPT';
                    return { 
                        type: 'MOVE_TO_INTERCEPT', 
                        target: targetAsteroid,
                        formation: 'SPHERE'
                    };
                } else {
                    this.currentStrategy = 'DETECT';
                    return { 
                        type: 'DETECT', 
                        target: targetAsteroid,
                        formation: 'SPREAD'
                    };
                }
            }
            
            selectTarget(game) {
                if (game.asteroids.length === 0) return null;
                
                let bestTarget = null;
                let maxThreat = -Infinity;
                
                game.asteroids.forEach(ast => {
                    const threat = this.calculateThreatLevel(ast, game);
                    if (threat > maxThreat) {
                        maxThreat = threat;
                        bestTarget = ast;
                    }
                });
                
                return bestTarget;
            }
            
            computeSwarmOrientation(game, target) {
                const dir = new THREE.Vector3()
                    .subVectors(target.position, new THREE.Vector3(0, 0, 0))
                    .normalize();
                
                return [
                    Math.max(0, dir.x), Math.max(0, -dir.x),
                    Math.max(0, dir.y), Math.max(0, -dir.y),
                    Math.max(0, dir.z), Math.max(0, -dir.z)
                ];
            }
            
            encodeSensory(game) {
                const sensory = new Float32Array(4096);
                const { SPATIAL_START, SPATIAL_LEN, THREAT_START, THREAT_LEN, STATUS_START } = this.BANDS;
                
                // Spatial encoding - asteroid directions
                game.asteroids.forEach(ast => {
                    const dir = new THREE.Vector3().subVectors(ast.position, game.earth.position).normalize();
                    const theta = Math.atan2(dir.y, dir.x);
                    const phi = Math.acos(dir.z);
                    
                    const idx = Math.floor(((theta + Math.PI) / (2 * Math.PI)) * SPATIAL_LEN);
                    const threat = this.calculateThreatLevel(ast, game);
                    
                    for (let offset = -20; offset <= 20; offset++) {
                        const i = (SPATIAL_START + ((idx + offset + SPATIAL_LEN) % SPATIAL_LEN));
                        sensory[i] += threat * Math.exp(-offset * offset / 50);
                    }
                });
                
                // Threat encoding
                for (let i = 0; i < THREAT_LEN; i++) {
                    const angle = (i / THREAT_LEN) * 2 * Math.PI;
                    const dir = new THREE.Vector3(Math.cos(angle), Math.sin(angle), 0);
                    
                    let threat = 0;
                    game.asteroids.forEach(ast => {
                        const astDir = new THREE.Vector3().subVectors(ast.position, game.earth.position).normalize();
                        const dot = dir.dot(astDir);
                        
                        if (dot > 0.7) {
                            const dist = ast.position.length();
                            threat += Math.max(0, 10.0 * (1.0 - dist / 50000) * dot);
                        }
                    });
                    
                    sensory[THREAT_START + i] = threat;
                }
                
                // Status
                sensory[STATUS_START + 0] = game.satellites.length / 100;
                sensory[STATUS_START + 1] = game.swarmPower / 100;
                sensory[STATUS_START + 2] = game.asteroids.length / 10;
                sensory[STATUS_START + 3] = this.deflections / 10;
                
                return sensory;
            }
            
            spatialToBump(sens) {
                const bump = new Float32Array(256);
                const { SPATIAL_START, SPATIAL_LEN } = this.BANDS;
                
                for (let i = 0; i < SPATIAL_LEN; i++) {
                    const a = Math.floor((i / SPATIAL_LEN) * 256);
                    bump[a] += Math.max(0, sens[SPATIAL_START + i]);
                }
                
                const sum = bump.reduce((x, y) => x + y, 0) || 1;
                for (let i = 0; i < 256; i++) bump[i] /= sum;
                
                return bump;
            }
            
            computeDopamine(reward) {
                const delta = reward - this._prevR;
                this._prevR = reward;
                this.dopamine = Math.max(-1, Math.min(1, delta / 1000));
                return this.dopamine;
            }
            
            computeReward(game, target) {
                let r = 0;
                
                r += (100 - this.earthHits) * 100;
                r += game.swarmPower * 2;
                r += this.deflections * 500;
                
                if (target) {
                    const dist = target.position.length();
                    r -= dist / 100;
                }
                
                return r;
            }
            
            addScore(points, reason, options = {}) {
                if (!Number.isFinite(points) || points === 0) return 0;

                const { silent = false, applyMultiplier = true } = options;
                const positive = points > 0;
                const multiplier = positive && applyMultiplier ? this.comboMultiplier : 1;
                const effectivePoints = positive
                    ? Math.round(points * multiplier)
                    : Math.round(points);

                this.score = Math.max(0, this.score + effectivePoints);
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    if (this.storageAvailable) {
                        window.localStorage.setItem('swarm_high_score', this.highScore.toString());
                    }
                }

                if (!silent) {
                    const prefix = effectivePoints > 0 ? '+' : '';
                    const comboNote = positive && multiplier > 1
                        ? ` (x${multiplier.toFixed(1)})`
                        : '';
                    console.log(`${prefix}${effectivePoints} pts: ${reason}${comboNote}`);
                }

                return effectivePoints;
            }

            advanceWave() {
                this.wave++;
                this.comboTimer = Math.max(this.comboTimer, 15);
                this.deflectionsInWave = 0;

                if (this.game && typeof this.game.onWaveAdvanced === 'function') {
                    this.game.onWaveAdvanced(this.wave, { announce: true });
                }

                this.addScore(500 + this.wave * 100, `WAVE ${this.wave}`, { applyMultiplier: false });
                console.log(`üåä Wave ${this.wave} escalating!`);
            }

            updateScore(deltaTime, game = this.game) {
                if (!Number.isFinite(deltaTime) || deltaTime <= 0) return;

                this.missionTime += deltaTime;
                this.passiveScoreTimer += deltaTime;

                if (this.comboTimer > 0) {
                    this.comboTimer = Math.max(0, this.comboTimer - deltaTime);
                    if (this.comboTimer === 0) {
                        this.comboMultiplier = 1;
                        this.comboStreak = 0;
                    }
                }

                while (this.passiveScoreTimer >= 1) {
                    const hazard = 1 + (this.wave - 1) * 0.25 + (game ? game.asteroids.length * 0.1 : 0);
                    const passivePoints = Math.round(8 * hazard);
                    this.addScore(passivePoints, 'MISSION TIME', { silent: true, applyMultiplier: false });
                    this.passiveScoreTimer -= 1;
                }
            }

            resetMission() {
                this.score = 0;
                this.deflections = 0;
                this.deflectionsInWave = 0;
                this.earthHits = 0;
                this.wave = 1;
                this.missionTime = 0;
                this.passiveScoreTimer = 0;
                this.comboTimer = 0;
                this.comboMultiplier = 1;
                this.comboStreak = 0;
            }
            
            onDeflection(asteroid, context = {}) {
                this.deflections++;
                this.deflectionsInWave++;
                this.comboStreak++;
                this.comboTimer = 20;
                this.comboMultiplier = Math.min(5, 1 + this.comboStreak * 0.3);

                const totalDeltaV = context.totalDeltaV || 0;
                const requiredDeltaV = context.requiredDeltaV || 0;
                const etaSeconds = context.etaSeconds;

                let bonus = this.wave * 200;
                if (requiredDeltaV > 0) {
                    const efficiency = Math.min(2, totalDeltaV / requiredDeltaV);
                    bonus += Math.round(300 * efficiency);
                } else {
                    bonus += 150;
                }

                if (Number.isFinite(etaSeconds) && etaSeconds > 0) {
                    const etaHours = etaSeconds / 3600;
                    bonus += Math.min(400, Math.round(etaHours * 5));
                }

                this.addScore(1000 + bonus, 'DEFLECTION');

                if (this.deflectionsInWave >= 3) {
                    this.deflectionsInWave = 0;
                    this.advanceWave();
                }
            }
            
            onEarthHit() {
                this.earthHits++;
                this.addScore(-500, 'IMPACT');
                this.comboStreak = 0;
                this.comboMultiplier = 1;
                this.comboTimer = 0;
                this.deflectionsInWave = 0;

                if (this.wave > 1) {
                    this.wave = Math.max(1, this.wave - 1);
                    if (this.game && typeof this.game.onWaveAdvanced === 'function') {
                        this.game.onWaveAdvanced(this.wave, { announce: false, penalty: true });
                    }
                }
            }

            decayMemories() {
                for (const [key, entry] of this.trajectoryMemory.entries()) {
                    entry.age = (entry.age || 0) + 1;
                    if (entry.age > 600) {
                        this.trajectoryMemory.delete(key);
                    }
                }

                for (const [key, entry] of this.optimalPositions.entries()) {
                    entry.age = (entry.age || 0) + 1;
                    if (entry.age > 300) {
                        this.optimalPositions.delete(key);
                    }
                }
            }

            recordTrajectory(asteroidId, originalPoints = [], currentPoints = []) {
                const clonePoints = (points) => points.map(p => ({ x: p.x, y: p.y, z: p.z }));
                this.trajectoryMemory.set(asteroidId, {
                    original: clonePoints(originalPoints),
                    current: clonePoints(currentPoints),
                    age: 0,
                    updated: Date.now()
                });
            }

            forgetTrajectory(asteroidId) {
                this.trajectoryMemory.delete(asteroidId);
            }

            recordOptimalPosition(satId, position) {
                if (!position) return;
                this.optimalPositions.set(satId, {
                    position: { x: position.x, y: position.y, z: position.z },
                    age: 0,
                    updated: Date.now()
                });
            }

            forgetOptimalPosition(satId) {
                this.optimalPositions.delete(satId);
            }
        }
        
        // ============================================================================
        // THREE.JS SPACE SCENE
        // ============================================================================
        
        class SpaceScene {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, (window.innerWidth - 380) / window.innerHeight, 1, 2000000);
                this.camera.position.set(0, 80000, 150000); // Pulled back for 2 AU view
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth - 380, window.innerHeight);
                this.renderer.setClearColor(0x000000);
                document.getElementById('three-canvas').appendChild(this.renderer.domElement);
                
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                
                this.setupLights();
                this.setupSpace();

                this.earth = this.createEarth();
                this.sun = this.createSun();
                this.physics = new PhysicsEngine();
                this.physics.registerBody(this.earth, { mass: EARTH_MASS, dynamic: false });
                this.physics.registerBody(this.sun, { mass: SUN_MASS, dynamic: false });
                this.satellites = [];
                this.asteroids = [];
                this.beams = [];
                this.basePowerPerSatelliteMW = 1.1;
                this.powerMultiplier = 1;
                this.timeScale = 1;
                this.lastDeltaTime = DT;
                this.maxSatelliteCapacity = 200;
                this.targetSatelliteCount = 50;
                this.safeDeflectionDistance = 9000; // km, radius target for safe miss
                this.swarmPower = 100;

                this.trajectoryLines = []; // Predicted paths
                this.thrustVectors = []; // Thrust direction indicators

                // Object pools for performance
                this.beamPool = [];
                this.trajectoryPool = [];
                this.thrustVectorPool = [];
                for (let i = 0; i < 100; i++) {
                    // Beam pool
                    const beamGeom = new THREE.BufferGeometry();
                    beamGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3));
                    const beamMat = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5 });
                    const beam = new THREE.Line(beamGeom, beamMat);
                    beam.visible = false;
                    this.scene.add(beam);
                    this.beamPool.push(beam);

                    // Trajectory pool
                    const trajGeom = new THREE.BufferGeometry();
                    trajGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(303), 3)); // 101 points
                    const trajMat = new THREE.LineBasicMaterial({ transparent: true, opacity: 0.5 });
                    const traj = new THREE.Line(trajGeom, trajMat);
                    traj.visible = false;
                    this.scene.add(traj);
                    this.trajectoryPool.push(traj);
                }

                this.beamPoolIndex = 0;
                this.trajectoryPoolIndex = 0;

                this.elapsedTime = 0;
                this.spawnTimer = 0;
                this.spawnInterval = 12;
                this.maxConcurrentAsteroids = 5;

                this.agent = new SwarmDefenseAgent(this);
                this.onWaveAdvanced(this.agent.wave, { announce: false });

                this.currentTarget = null;
                this.focusQuality = 0;
                this.convergence = 0;
                this.intensity = 0;
                this.ablationRate = 0; // kg/s
                this.thrustForce = 0; // N
                this.modifiedEnergy = 0;
                this.ablationTimeWarp = 3600; // simulate 1 hour of dwell per simulation second
                this.asteroidMassScale = 1;

                this.spawnInitialSatellites();

                this.modifiedEnergy = this.physics.computeModifiedEnergy();

                window.addEventListener('resize', () => this.onResize());
                this.setupInput();
                
                console.log('üåç SWARM DEFENSE - ONLINE!');
            }
            
            setupLights() {
                const ambient = new THREE.AmbientLight(0x222222);
                this.scene.add(ambient);
                
                this.sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
                this.sunLight.position.set(100000, 0, 0);
                this.scene.add(this.sunLight);
            }
            
            setupSpace() {
                const starGeometry = new THREE.BufferGeometry();
                const starVertices = [];
                for (let i = 0; i < 10000; i++) {
                    const x = (Math.random() - 0.5) * 200000;
                    const y = (Math.random() - 0.5) * 200000;
                    const z = (Math.random() - 0.5) * 200000;
                    starVertices.push(x, y, z);
                }
                starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
                const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 3 }); // Reduced from 50 for performance
                const stars = new THREE.Points(starGeometry, starMaterial);
                this.scene.add(stars);
            }
            
            createEarth() {
                const geometry = new THREE.SphereGeometry(6371, 64, 64);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x2233ff,
                    emissive: 0x112244
                });
                const earth = new THREE.Mesh(geometry, material);
                earth.position.set(0, 0, 0);
                this.scene.add(earth);
                
                // Atmosphere
                const atmoGeometry = new THREE.SphereGeometry(6500, 64, 64);
                const atmoMaterial = new THREE.MeshBasicMaterial({
                    color: 0x3366ff,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.BackSide
                });
                const atmosphere = new THREE.Mesh(atmoGeometry, atmoMaterial);
                earth.add(atmosphere);
                
                return earth;
            }
            
            createSun() {
                const geometry = new THREE.SphereGeometry(5000, 32, 32);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00
                });
                const sun = new THREE.Mesh(geometry, material);
                sun.position.set(80000, 20000, 0); // Closer for gameplay
                this.scene.add(sun);
                return sun;
            }
            
            spawnInitialSatellites() {
                // Spawn constellation based on configured target count
                const count = Math.min(this.targetSatelliteCount, this.maxSatelliteCapacity);
                for (let i = 0; i < count; i++) {
                    const theta = (i / count) * Math.PI * 2;
                    const phi = Math.acos(2 * (i / count) - 1);
                    const r = 8000;

                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.sin(phi) * Math.sin(theta);
                    const z = r * Math.cos(phi);

                    this.spawnSatellite(x, y, z);
                }

                this.targetSatelliteCount = count;
                this.updateSwarmTelemetry();

                console.log(`üõ∞Ô∏è ${count}-satellite constellation deployed!`);
                console.log('üì° Detection range: 2 AU (300M km)');
                console.log('üéØ Engagement range: 1 AU (150M km)');
                console.log('ü™ô 1000m¬≤ gold parabolic mirrors');
                console.log(`‚ö° Total power: ${(this.getTotalPowerMW()).toFixed(0)} MW`);
            }
            
            spawnSatellite(x, y, z) {
                const geometry = new THREE.BoxGeometry(50, 50, 50);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x00aa00
                });
                const sat = new THREE.Mesh(geometry, material);
                sat.position.set(x, y, z);
                
                // Solar panels
                const panelGeom = new THREE.PlaneGeometry(200, 100);
                const panelMat = new THREE.MeshPhongMaterial({ 
                    color: 0x0066ff,
                    emissive: 0x003388,
                    side: THREE.DoubleSide
                });
                const panel1 = new THREE.Mesh(panelGeom, panelMat);
                panel1.position.x = 125;
                sat.add(panel1);
                
                const panel2 = new THREE.Mesh(panelGeom, panelMat);
                panel2.position.x = -125;
                sat.add(panel2);
                
                sat.userData = {
                    power: 100,
                    mirrorAngle: new THREE.Vector2(0, 0),
                    id: sat.uuid
                };

                const relPos = sat.position.clone().sub(this.earth.position);
                const orbitalRadius = Math.max(relPos.length(), 1);
                let tangent = new THREE.Vector3().crossVectors(relPos, new THREE.Vector3(0, 0, 1));
                if (tangent.lengthSq() < 1e-6) {
                    tangent = new THREE.Vector3().crossVectors(relPos, new THREE.Vector3(0, 1, 0));
                }
                tangent.normalize().multiplyScalar(Math.sqrt((G * EARTH_MASS) / orbitalRadius));

                this.scene.add(sat);
                this.satellites.push(sat);
                this.physics.registerBody(sat, { mass: SATELLITE_MASS, velocity: tangent });
            }

            removeSatellite() {
                const sat = this.satellites.pop();
                if (!sat) return;
                this.scene.remove(sat);
                this.physics.deregisterBody(sat);
                if (this.agent && typeof this.agent.forgetOptimalPosition === 'function') {
                    this.agent.forgetOptimalPosition(sat.uuid);
                }
            }

            setTargetSatelliteCount(count) {
                const clamped = Math.max(0, Math.min(this.maxSatelliteCapacity, Math.floor(count)));
                this.targetSatelliteCount = clamped;

                while (this.satellites.length < clamped) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = 8000 + Math.random() * 2000;
                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.sin(phi) * Math.sin(theta);
                    const z = r * Math.cos(phi);
                    this.spawnSatellite(x, y, z);
                }

                while (this.satellites.length > clamped) {
                    this.removeSatellite();
                }

                this.redistributeSatellites();
                this.updateSwarmTelemetry();
            }

            setPowerMultiplier(multiplier) {
                const clamped = Math.max(1, Math.min(100, multiplier));
                this.powerMultiplier = Math.round(clamped * 10) / 10;
                this.updateSwarmTelemetry();
            }

            setTimeScale(scale) {
                const clamped = Math.max(0.1, Math.min(20, scale));
                this.timeScale = Math.round(clamped * 10) / 10;
                this.updateSwarmTelemetry();
            }

            redistributeSatellites() {
                const count = this.satellites.length;
                if (count === 0) return;
                const radius = 8000;
                for (let i = 0; i < count; i++) {
                    const sat = this.satellites[i];
                    const theta = (i / count) * Math.PI * 2;
                    const phi = Math.acos(2 * (i / count) - 1);
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    sat.position.set(x, y, z);

                    const relPos = sat.position.clone();
                    const orbitalRadius = Math.max(relPos.length(), 1);
                    let tangent = new THREE.Vector3().crossVectors(relPos, new THREE.Vector3(0, 0, 1));
                    if (tangent.lengthSq() < 1e-6) {
                        tangent = new THREE.Vector3().crossVectors(relPos, new THREE.Vector3(0, 1, 0));
                    }
                    tangent.normalize().multiplyScalar(Math.sqrt((G * EARTH_MASS) / orbitalRadius));
                    sat.userData.velocity = tangent;
                    if (sat.userData.accel) {
                        sat.userData.accel.set(0, 0, 0);
                    }
                }
            }

            getTotalPowerMW() {
                return this.satellites.length * this.basePowerPerSatelliteMW * this.powerMultiplier;
            }

            updateSwarmTelemetry() {
                const totalPowerMW = this.getTotalPowerMW();
                const baselinePower = 50 * this.basePowerPerSatelliteMW;
                this.swarmPower = baselinePower > 0 ? (totalPowerMW / baselinePower) * 100 : this.powerMultiplier * 100;
                const swarmTargetEl = document.getElementById('swarm-target');
                if (swarmTargetEl) {
                    swarmTargetEl.textContent = this.targetSatelliteCount;
                }
                const powerMultiplierEl = document.getElementById('power-multiplier');
                if (powerMultiplierEl) {
                    powerMultiplierEl.textContent = this.powerMultiplier.toFixed(1) + '√ó';
                }
                const gpuStatus = document.getElementById('gpu-status');
                if (gpuStatus) {
                    gpuStatus.textContent = totalPowerMW.toFixed(0) + ' MW';
                }
                const slider = document.getElementById('satellite-slider');
                if (slider) {
                    slider.value = this.targetSatelliteCount.toString();
                }
                const powerSlider = document.getElementById('power-slider');
                if (powerSlider) {
                    powerSlider.value = this.powerMultiplier.toFixed(1);
                }
                const timeScaleEl = document.getElementById('time-scale');
                if (timeScaleEl) {
                    timeScaleEl.textContent = this.timeScale.toFixed(1) + '√ó';
                }
                const timeSlider = document.getElementById('time-slider');
                if (timeSlider) {
                    timeSlider.value = this.timeScale.toFixed(1);
                }
            }

            calculateRequiredDeltaV(asteroid) {
                if (!asteroid || !asteroid.userData || !asteroid.userData.velocity) {
                    return 0;
                }
                const relativePosition = asteroid.position.clone();
                const relativeVelocity = asteroid.userData.velocity.clone();
                const speedSq = relativeVelocity.lengthSq();
                if (speedSq < 1e-6) {
                    return 0;
                }

                const timeToClosest = -relativePosition.dot(relativeVelocity) / speedSq;
                if (timeToClosest <= 0) {
                    return 0;
                }

                const closestApproach = relativePosition.clone()
                    .add(relativeVelocity.clone().multiplyScalar(timeToClosest))
                    .length();

                if (closestApproach >= this.safeDeflectionDistance) {
                    return 0;
                }

                const requiredOffset = this.safeDeflectionDistance - closestApproach;
                const requiredDeltaV = requiredOffset / Math.max(timeToClosest, 1); // km/s
                return Math.max(0, requiredDeltaV * 1000); // convert to m/s
            }
            
            spawnAsteroid() {
                const radius = 50 + Math.random() * 200;
                const geometry = new THREE.SphereGeometry(radius, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: 0x888888,
                    emissive: 0x222222,
                    emissiveIntensity: 0
                });
                const asteroid = new THREE.Mesh(geometry, material);
                
                // Spawn at 2 AU detection range (300 million km, scaled for game)
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const dist = 200000 + Math.random() * 100000; // 2 AU detection range
                
                asteroid.position.set(
                    dist * Math.sin(phi) * Math.cos(theta),
                    dist * Math.sin(phi) * Math.sin(theta),
                    dist * Math.cos(phi)
                );
                
                // Velocity toward Earth (SLOWER for realistic deflection demo)
                const dir = new THREE.Vector3()
                    .subVectors(this.earth.position, asteroid.position)
                    .normalize()
                    .multiplyScalar(30 + Math.random() * 20); // REDUCED: 30-50 km/s (was 100-150)

                const baseMass = (4/3) * Math.PI * Math.pow(radius, 3) * 2200;
                const massScale = Math.max(0.1, this.asteroidMassScale || 1);
                const mass = baseMass * massScale;

                asteroid.userData = {
                    id: Math.random().toString(36),
                    velocity: dir.clone(),
                    originalVelocity: dir.clone(), // TRACK ORIGINAL
                    originalPosition: asteroid.position.clone(), // TRACK ORIGINAL
                    radius: radius,
                    mass,
                    originalMass: mass,
                    baseMass,
                    massScale,
                    minMass: mass * 0.1,
                    ablationDV: new THREE.Vector3(0, 0, 0),
                    beingEngaged: false
                };

                this.scene.add(asteroid);
                this.asteroids.push(asteroid);
                this.physics.registerBody(asteroid, { mass: asteroid.userData.mass, velocity: dir.clone() });

                console.log(`ü™® Asteroid detected at 2 AU: ${radius.toFixed(0)}m, ${(asteroid.userData.mass/1e6).toFixed(1)} kt (mass scale ${massScale.toFixed(1)}√ó)`);
            }

            setAsteroidMassScale(scale) {
                const clamped = Math.max(0.1, Math.min(5, scale));
                const previousScale = this.asteroidMassScale || 1;
                this.asteroidMassScale = Math.round(clamped * 10) / 10;

                this.asteroids.forEach(ast => {
                    if (!ast.userData) return;
                    const baseMass = ast.userData.baseMass || (ast.userData.originalMass || ast.userData.mass);
                    const oldOriginal = ast.userData.originalMass || (baseMass * previousScale);
                    const remainingFraction = oldOriginal > 0 ? (ast.userData.mass / oldOriginal) : 1;
                    const newOriginal = baseMass * this.asteroidMassScale;
                    const newMin = newOriginal * 0.1;
                    const adjustedMass = Math.max(newMin, newOriginal * remainingFraction);

                    ast.userData.originalMass = newOriginal;
                    ast.userData.mass = adjustedMass;
                    ast.userData.minMass = newMin;
                    ast.userData.massScale = this.asteroidMassScale;
                });
            }
            
            setupInput() {
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.autoEngage();
                    }
                    if (e.code === 'KeyA') {
                        const active = this.agent.toggle();
                        document.getElementById('ai-status').innerHTML = active ? 
                            'Mode: <span class="brain">AUTONOMOUS</span>' : 
                            'Mode: <span class="brain">MANUAL</span>';
                    }
                    if (e.code === 'KeyT') {
                        this.targetNearest();
                    }
                    if (e.code === 'KeyD') {
                        this.deploySwarm();
                    }
                    if (e.code === 'KeyR') {
                        this.reset();
                    }
                });
            }
            
            autoEngage() {
                if (this.asteroids.length === 0) return;
                this.targetNearest();
                console.log('AUTO-ENGAGE!');
            }
            
            targetNearest() {
                if (this.asteroids.length === 0) return;
                
                let nearest = null;
                let minDist = Infinity;
                
                this.asteroids.forEach(ast => {
                    const dist = ast.position.length();
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = ast;
                    }
                });
                
                this.currentTarget = nearest;
                console.log(`üéØ Target locked: ${minDist.toFixed(0)}m`);
            }
            
            deploySwarm() {
                console.log('üöÄ Deploying reinforcements...');
                const newTarget = Math.min(this.targetSatelliteCount + 10, this.maxSatelliteCapacity);
                this.setTargetSatelliteCount(newTarget);
                console.log(`üõ∞Ô∏è Swarm target set to ${this.targetSatelliteCount} satellites`);
                console.log(`‚ö° Total power now: ${(this.getTotalPowerMW()).toFixed(0)} MW`);
            }

            onWaveAdvanced(wave, { announce = true, penalty = false } = {}) {
                const clampedWave = Math.max(1, wave || 1);
                this.spawnInterval = Math.max(3, 12 - clampedWave * 1.1);
                this.maxConcurrentAsteroids = Math.min(12, 5 + Math.floor(clampedWave * 1.5));

                if (announce) {
                    console.log(`üåä Wave ${clampedWave}: spawn interval ${this.spawnInterval.toFixed(1)}s | max asteroids ${this.maxConcurrentAsteroids}`);
                    if (clampedWave % 2 === 0) {
                        this.deploySwarm();
                    }
                } else if (penalty) {
                    console.log(`‚ö†Ô∏è Wave pressure reduced to ${clampedWave}`);
                }
            }

            reset() {
                // Clear asteroids
                this.asteroids.forEach(ast => {
                    this.scene.remove(ast);
                    this.physics.deregisterBody(ast);
                });
                this.asteroids = [];
                this.currentTarget = null;

                // Reset score and AI memory
                if (this.agent) {
                    this.agent.resetMission();
                    this.agent.threatMap.clear();
                    this.agent.trajectoryMemory.clear();
                    this.agent.optimalPositions.clear();
                    this.onWaveAdvanced(this.agent.wave, { announce: false });
                }

                this.elapsedTime = 0;
                this.spawnTimer = 0;

                this.modifiedEnergy = this.physics.computeModifiedEnergy();

                console.log('üîÑ Simulation reset');
            }

            update() {
                const deltaTime = DT * this.timeScale;
                this.lastDeltaTime = deltaTime;
                this.physics.integrate(deltaTime);
                this.modifiedEnergy = this.physics.computeModifiedEnergy();

                this.elapsedTime += deltaTime;

                if (this.agent && typeof this.agent.updateScore === 'function') {
                    this.agent.updateScore(deltaTime, this);
                }

                if (this.agent && typeof this.agent.decayMemories === 'function') {
                    this.agent.decayMemories();
                }

                if (!this.currentTarget) {
                    this.trajectoryPool.forEach(t => t.visible = false);
                }

                if (!this.currentTarget || this.asteroids.indexOf(this.currentTarget) === -1) {
                    const closest = this.asteroids.reduce((closest, ast) => {
                        const dist = ast.position.length();
                        return dist < closest.dist ? { ast, dist } : closest;
                    }, { ast: null, dist: Infinity });

                    if (closest.ast && closest.dist < 150000) {
                        this.currentTarget = closest.ast;
                        const distAU = (closest.dist / 150000).toFixed(2);
                        console.log(`‚ö†Ô∏è EMERGENCY LOCK: ${distAU} AU`);
                    }
                }

                if (this.agent.active) {
                    const action = this.agent.decide(this);
                    if (action) this.executeAction(action);
                }

                this.satellites.forEach(sat => {
                    if (!sat.userData || !sat.userData.velocity) return;

                    if (this.currentTarget) {
                        const toSun = new THREE.Vector3()
                            .subVectors(this.sun.position, this.currentTarget.position)
                            .normalize();
                        const radius = this.currentTarget.userData.radius;
                        const focalOffset = toSun.clone().multiplyScalar(radius * 0.6);
                        const focalPoint = this.currentTarget.position.clone().add(focalOffset);

                        const sunToFocal = new THREE.Vector3()
                            .subVectors(focalPoint, this.sun.position)
                            .normalize();
                        const orbitalRadius = sat.position.distanceTo(this.earth.position);
                        const idealPos = focalPoint.clone().add(sunToFocal.clone().multiplyScalar(orbitalRadius * 0.3));

                        const toIdeal = new THREE.Vector3().subVectors(idealPos, sat.position);
                        if (toIdeal.lengthSq() > 1) {
                            const adjustAccel = toIdeal.normalize().multiplyScalar(0.0005);
                            sat.userData.velocity.addScaledVector(adjustAccel, deltaTime);
                        }

                        if (this.agent && typeof this.agent.recordOptimalPosition === 'function') {
                            this.agent.recordOptimalPosition(sat.uuid, idealPos);
                        }
                    }

                    sat.lookAt(this.currentTarget ? this.currentTarget.position : this.earth.position);
                });

                for (let idx = this.asteroids.length - 1; idx >= 0; idx--) {
                    const ast = this.asteroids[idx];
                    if (!ast || !ast.userData) continue;

                    // Preserve cumulative ablation Œîv so thrust-driven course changes persist
                    if (ast === this.currentTarget) {
                        this.trajectoryPool.forEach(t => t.visible = false);

                        let poolIdx = 0;
                        const trajDt = 120; // seconds per prediction step

                        let origPoints = null;

                        if (ast.userData.originalPosition && ast.userData.originalVelocity) {
                            const origPos = ast.userData.originalPosition.clone();
                            const origVel = ast.userData.originalVelocity.clone();
                            origPoints = [origPos.clone()];

                            for (let i = 0; i < 100; i++) {
                                origPos.addScaledVector(origVel, trajDt);
                                origPoints.push(origPos.clone());

                                if (origPos.length() < 6500 || origPos.length() > 50000) break;
                            }

                            if (poolIdx < this.trajectoryPool.length) {
                                const traj = this.trajectoryPool[poolIdx++];
                                const positions = new Float32Array(origPoints.length * 3);
                                origPoints.forEach((p, i) => {
                                    positions[i*3] = p.x;
                                    positions[i*3+1] = p.y;
                                    positions[i*3+2] = p.z;
                                });
                                traj.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                                traj.geometry.attributes.position.needsUpdate = true;
                                traj.material.color.setHex(0xff0000);
                                traj.visible = true;
                            }
                        }

                        const futurePos = ast.position.clone();
                        const futureVel = ast.userData.velocity.clone();
                        let currentPoints = [futurePos.clone()];

                        for (let i = 0; i < 100; i++) {
                            futurePos.addScaledVector(futureVel, trajDt);
                            currentPoints.push(futurePos.clone());

                            if (futurePos.length() < 6500) break;
                            if (futurePos.length() > 50000) break;
                        }

                        if (poolIdx < this.trajectoryPool.length) {
                            const traj = this.trajectoryPool[poolIdx++];
                            const positions = new Float32Array(currentPoints.length * 3);
                            currentPoints.forEach((p, i) => {
                                positions[i*3] = p.x;
                                positions[i*3+1] = p.y;
                                positions[i*3+2] = p.z;
                            });
                            traj.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                            traj.geometry.attributes.position.needsUpdate = true;
                            const willHit = futurePos.length() < 6500;
                            traj.material.color.setHex(willHit ? 0xff8800 : 0x00ff00);
                            traj.visible = true;
                        }

                        if (this.agent && typeof this.agent.recordTrajectory === 'function') {
                            this.agent.recordTrajectory(
                                ast.userData.id,
                                origPoints || [],
                                currentPoints || []
                            );
                        }
                    }

                    const dist = ast.position.length();
                    if (dist < 6500) {
                        console.log('üí• EARTH IMPACT!');
                        this.agent.onEarthHit();
                        if (this.agent && typeof this.agent.forgetTrajectory === 'function') {
                            this.agent.forgetTrajectory(ast.userData.id);
                        }
                        this.physics.deregisterBody(ast);
                        this.scene.remove(ast);
                        this.asteroids.splice(idx, 1);
                        if (this.currentTarget === ast) {
                            this.currentTarget = null;
                        }

                        document.getElementById('alert').style.display = 'block';
                        setTimeout(() => {
                            document.getElementById('alert').style.display = 'none';
                        }, 2000);
                        continue;
                    }

                    if (dist > 350000) {
                        if (this.agent && typeof this.agent.forgetTrajectory === 'function') {
                            this.agent.forgetTrajectory(ast.userData.id);
                        }
                        this.physics.deregisterBody(ast);
                        this.scene.remove(ast);
                        this.asteroids.splice(idx, 1);
                        if (this.currentTarget === ast) {
                            this.currentTarget = null;
                        }
                    }
                }

                if (this.currentTarget) {
                    this.updateMirrorFocus(deltaTime);
                }

                const wave = this.agent ? this.agent.wave : 1;
                const spawnInterval = Math.max(2.5, this.spawnInterval - (wave - 1) * 0.25);
                const maxAsteroids = Math.min(12, this.maxConcurrentAsteroids + Math.floor((wave - 1) * 0.75));
                this.spawnTimer += deltaTime;
                while (this.spawnTimer >= spawnInterval) {
                    if (this.asteroids.length < maxAsteroids) {
                        this.spawnAsteroid();
                    }
                    this.spawnTimer -= spawnInterval;
                    if (this.asteroids.length >= maxAsteroids) {
                        break;
                    }
                }

                this.updateUI();
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
            
            updateMirrorFocus(deltaTime) {
                const dt = Number.isFinite(deltaTime) && deltaTime > 0
                    ? deltaTime
                    : (Number.isFinite(this.lastDeltaTime) && this.lastDeltaTime > 0
                        ? this.lastDeltaTime
                        : DT * this.timeScale);

                if (!this.currentTarget || !this.currentTarget.userData || this.asteroids.indexOf(this.currentTarget) === -1) {
                    this.currentTarget = null;
                    // Hide pooled beams and thrust vectors
                    this.beamPool.forEach(beam => beam.visible = false);
                    this.thrustVectors.forEach(vec => this.scene.remove(vec));
                    this.thrustVectors = [];
                    this.focusQuality = 0;
                    this.convergence = 0;
                    this.intensity = 0;
                    this.ablationRate = 0;
                    this.thrustForce = 0;
                    return;
                }
                if (this.satellites.length === 0) return;
                
                // MERGE: Calculate focal point ONCE for both beams and physics
                const toSun = new THREE.Vector3()
                    .subVectors(this.sun.position, this.currentTarget.position)
                    .normalize();
                const radius = this.currentTarget.userData.radius;
                const focalOffset = toSun.clone().multiplyScalar(radius * 0.6);
                const focalPoint = this.currentTarget.position.clone().add(focalOffset);
                
                // Calculate convergence and draw beams using pooling
                let totalFocus = 0;
                let beamIdx = 0;
                
                this.beamPool.forEach(beam => beam.visible = false); // Hide all first
                
                this.satellites.forEach(sat => {
                    const toTarget = new THREE.Vector3()
                        .subVectors(focalPoint, sat.position)
                        .normalize();
                    
                    const toSunFromSat = new THREE.Vector3()
                        .subVectors(this.sun.position, sat.position)
                        .normalize();
                    
                    // Check if sun is visible from satellite
                    const sunAngle = toTarget.angleTo(toSunFromSat);
                    const focus = Math.max(0, 1.0 - sunAngle / Math.PI);
                    totalFocus += focus;
                    
                    // Draw beam if focusing - using pooled objects
                    if (focus > 0.3 && beamIdx < this.beamPool.length) {
                        const beam = this.beamPool[beamIdx++];
                        const positions = beam.geometry.attributes.position.array;
                        positions[0] = sat.position.x;
                        positions[1] = sat.position.y;
                        positions[2] = sat.position.z;
                        positions[3] = focalPoint.x;
                        positions[4] = focalPoint.y;
                        positions[5] = focalPoint.z;
                        beam.geometry.attributes.position.needsUpdate = true;
                        beam.material.opacity = 0.3 + focus * 0.3;
                        beam.visible = true;
                    }
                });
                
                this.focusQuality = totalFocus / this.satellites.length;
                this.convergence = Math.min(100, this.focusQuality * 150);
                
                // FIX INTENSITY: Use real P_laser calculation
                const mirrorArea = 1000; // m¬≤ per satellite
                const solarFlux = 1361; // W/m¬≤ at 1 AU
                const reflectivity = 0.95; // Gold coating
                const concentrationEfficiency = 0.85; // Parabolic focus
                const convergenceFactor = this.convergence / 100;
                
                const P_laser = this.satellites.length * mirrorArea * solarFlux *
                               reflectivity * concentrationEfficiency * convergenceFactor *
                               this.powerMultiplier;
                
                this.intensity = P_laser; // Store in watts
                
                // REAL CARBONACEOUS CHONDRITE ABLATION PHYSICS
                if (this.convergence > 30) {
                    // Material properties
                    const H_VAP = 4e6;   // J/kg (vaporization enthalpy)
                    const V_EXH = 1000;  // m/s (ejecta velocity)

                    // Mass ablation rate: Power / vaporization enthalpy
                    const m_dot = P_laser / H_VAP; // kg/s

                    // Thrust from ejecta (rocket equation)
                    const F_thrust = m_dot * V_EXH; // Newtons

                    // Acceleration
                    const M_asteroid = this.currentTarget.userData.mass; // kg
                    const accel = F_thrust / M_asteroid; // m/s¬≤

                    // Aggregate continuous dwell time into each simulation step
                    const effectiveSeconds = dt * this.ablationTimeWarp;

                    // Thrust direction: outward from focal point (surface normal)
                    const thrustDir = focalOffset.clone().normalize();

                    // Perpendicular component for optimal deflection
                    const velocity = this.currentTarget.userData.velocity.clone().normalize();
                    const toEarth = new THREE.Vector3()
                        .subVectors(this.earth.position, this.currentTarget.position)
                        .normalize();
                    
                    const lateralBias = new THREE.Vector3()
                        .crossVectors(velocity, toEarth)
                        .normalize();
                    
                    if (lateralBias.length() < 0.1) {
                        lateralBias.crossVectors(velocity, new THREE.Vector3(0, 1, 0)).normalize();
                    }
                    
                    // Final thrust: 70% from focal normal + 30% lateral
                    const finalThrustDir = thrustDir.clone().multiplyScalar(0.7)
                        .add(lateralBias.clone().multiplyScalar(0.3))
                        .normalize();
                    
                    const deltaV = finalThrustDir.clone().multiplyScalar((accel * effectiveSeconds) / 1000);
                    this.currentTarget.userData.velocity.add(deltaV);

                    // Apply TORQUE from off-center thrust
                    const leverArm = focalOffset.clone();
                    const torque = new THREE.Vector3().crossVectors(leverArm, finalThrustDir.clone().multiplyScalar(F_thrust));
                    const momentOfInertia = (2/5) * M_asteroid * radius * radius;
                    const angularAccel = torque.length() / momentOfInertia;
                    
                    if (!this.currentTarget.userData.angularVelocity) {
                        this.currentTarget.userData.angularVelocity = new THREE.Vector3(0, 0, 0);
                    }
                    
                    const torqueAxis = torque.normalize();
                    this.currentTarget.userData.angularVelocity.add(
                        torqueAxis.multiplyScalar(angularAccel * effectiveSeconds)
                    );
                    
                    // Clamp angular velocity to prevent visual chaos
                    const MAX_AV = 0.5; // rad/s
                    if (this.currentTarget.userData.angularVelocity.length() > MAX_AV) {
                        this.currentTarget.userData.angularVelocity.setLength(MAX_AV);
                    }
                    
                    // Apply rotation
                    const angVel = this.currentTarget.userData.angularVelocity;
                    this.currentTarget.rotation.x += angVel.x;
                    this.currentTarget.rotation.y += angVel.y;
                    this.currentTarget.rotation.z += angVel.z;
                    
                    // Track cumulative ŒîV
                    this.currentTarget.userData.ablationDV.add(deltaV);
                    const totalDeltaV = this.currentTarget.userData.ablationDV.length() * 1000;

                    // Reduce asteroid mass as material is removed (maintain minimum)
                    const ablatedMass = m_dot * effectiveSeconds;
                    if (Number.isFinite(ablatedMass) && ablatedMass > 0) {
                        const minMass = Math.max(1, this.currentTarget.userData.minMass || 0);
                        const newMass = Math.max(
                            minMass,
                            this.currentTarget.userData.mass - ablatedMass
                        );
                        this.currentTarget.userData.mass = newMass;
                    }

                    // Store metrics
                    this.ablationRate = m_dot * this.ablationTimeWarp;
                    this.thrustForce = F_thrust;
                    
                    // Log physics periodically
                    if (Math.random() < Math.min(1, dt)) {
                        const spinRate = this.currentTarget.userData.angularVelocity.length() * 180 / Math.PI;
                        console.log(`üî• P=${(P_laser/1e6).toFixed(2)}MW | Ablation=${m_dot.toFixed(4)}kg/s | Thrust=${F_thrust.toFixed(2)}N | ŒîV=${totalDeltaV.toFixed(2)}m/s | Spin=${spinRate.toFixed(1)}¬∞/s`);
                    }
                    
                    // Draw thrust vector FROM FOCAL POINT (clear old, create new)
                    this.thrustVectors.forEach(vec => this.scene.remove(vec));
                    this.thrustVectors = [];
                    
                    const thrustVizDir = finalThrustDir.clone().multiplyScalar(5000);
                    const arrowGeometry = new THREE.BufferGeometry();
                    const arrowPositions = new Float32Array([
                        focalPoint.x, focalPoint.y, focalPoint.z,
                        focalPoint.x + thrustVizDir.x, 
                        focalPoint.y + thrustVizDir.y, 
                        focalPoint.z + thrustVizDir.z
                    ]);
                    arrowGeometry.setAttribute('position', new THREE.BufferAttribute(arrowPositions, 3));
                    const arrowMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
                    const thrustArrow = new THREE.Line(arrowGeometry, arrowMaterial);
                    this.scene.add(thrustArrow);
                    this.thrustVectors.push(thrustArrow);
                    
                    // Draw focal point indicator
                    const focalGeometry = new THREE.SphereGeometry(radius * 0.15, 8, 8);
                    const focalMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffff00,
                        transparent: true,
                        opacity: 0.8
                    });
                    const focalIndicator = new THREE.Mesh(focalGeometry, focalMaterial);
                    focalIndicator.position.copy(focalPoint);
                    this.scene.add(focalIndicator);
                    this.thrustVectors.push(focalIndicator);
                    
                    // Visual feedback - glow
                    if (this.currentTarget.material) {
                        const intensity = this.convergence / 100;
                        this.currentTarget.material.emissive.setHex(0xff6600);
                        if (this.currentTarget.material.emissiveIntensity !== undefined) {
                            this.currentTarget.material.emissiveIntensity = Math.min(1.0, intensity * 2);
                        }
                    }
                    
                    // Check deflection success
                    const distToEarth = this.currentTarget.position.length();
                    const velTowardEarth = this.currentTarget.userData.velocity.dot(
                        new THREE.Vector3().subVectors(this.earth.position, this.currentTarget.position).normalize()
                    ) * 1000;
                    const closingSpeed = Math.max(0, velTowardEarth / 1000);
                    const etaSeconds = closingSpeed > 0 ? distToEarth / closingSpeed : Infinity;
                    
                    // Progress indicator
                    if (totalDeltaV > 5 && totalDeltaV < 15 && Math.random() < 0.05) {
                        console.log(`‚ö° Deflection progress: ${totalDeltaV.toFixed(1)}/15 m/s (${(totalDeltaV/15*100).toFixed(0)}%)`);
                    }
                    
                    const requiredDeltaV = this.calculateRequiredDeltaV(this.currentTarget);
                    this.currentTarget.userData.requiredDeltaV = requiredDeltaV;
                    const deflectionSuccess = (requiredDeltaV > 0 ? totalDeltaV >= requiredDeltaV : totalDeltaV > 5) || velTowardEarth < 10;

                    if (deflectionSuccess && (totalDeltaV > 1 || requiredDeltaV === 0)) {
                        const approaching = velTowardEarth > 0;
                        const spinRate = this.currentTarget.userData.angularVelocity ?
                            (this.currentTarget.userData.angularVelocity.length() * 180 / Math.PI) : 0;
                        console.log(`‚úì DEFLECTION SUCCESS!`);
                        console.log(`  ŒîV applied: ${totalDeltaV.toFixed(1)} m/s`);
                        console.log(`  ŒîV required: ${requiredDeltaV.toFixed(1)} m/s`);
                        console.log(`  Spin induced: ${spinRate.toFixed(1)}¬∞/s`);
                        console.log(`  Approach velocity: ${velTowardEarth.toFixed(1)} m/s ${approaching ? '(slowed)' : '(REVERSED!)'}`);
                        console.log(`  Distance: ${(distToEarth/150000).toFixed(2)} AU`);
                        this.agent.onDeflection(this.currentTarget, {
                            totalDeltaV,
                            requiredDeltaV,
                            distToEarth,
                            etaSeconds
                        });

                        if (this.agent && typeof this.agent.forgetTrajectory === 'function') {
                            this.agent.forgetTrajectory(this.currentTarget.userData.id);
                        }

                        this.physics.deregisterBody(this.currentTarget);
                        this.scene.remove(this.currentTarget);
                        const idx = this.asteroids.indexOf(this.currentTarget);
                        if (idx >= 0) this.asteroids.splice(idx, 1);
                        this.currentTarget = null;
                    }
                } else {
                    // Reset emissive
                    if (this.currentTarget && this.currentTarget.material) {
                        this.currentTarget.material.emissive.setHex(0x222222);
                        if (this.currentTarget.material.emissiveIntensity !== undefined) {
                            this.currentTarget.material.emissiveIntensity = 0;
                        }
                    }
                    this.ablationRate = 0;
                    this.thrustForce = 0;
                    
                    this.thrustVectors.forEach(vec => this.scene.remove(vec));
                    this.thrustVectors = [];
                }
            }
            
            executeAction(action) {
                if (!action) return;
                
                if (action.type === 'ENGAGE' && action.target) {
                    if (this.currentTarget !== action.target) {
                        this.currentTarget = action.target;
                        console.log(`üéØ ENGAGING: ${this.currentTarget.userData.id.substring(0, 6)}`);
                    }
                } else if (action.type === 'MOVE_TO_INTERCEPT' && action.target) {
                    if (this.currentTarget !== action.target) {
                        this.currentTarget = action.target;
                        console.log(`üéØ INTERCEPTING: ${this.currentTarget.userData.id.substring(0, 6)}`);
                    }
                } else if (action.type === 'DETECT' && action.target) {
                    if (this.currentTarget !== action.target) {
                        this.currentTarget = action.target;
                    }
                } else if (action.type === 'PATROL') {
                    if (this.currentTarget !== null) {
                        this.currentTarget = null;
                    }
                }
            }
            
            updateUI() {
                // Brain
                document.getElementById('cx-heading').textContent = Math.floor(this.agent.cx.getHeadingAngle()) + '¬∞';
                const valence = this.agent.mb.getValence();
                document.getElementById('mb-valence').textContent = (valence.approach - valence.avoid).toFixed(2);
                document.getElementById('dopamine').textContent = this.agent.dopamine.toFixed(2);
                document.getElementById('al-active').textContent = this.agent.al.getActiveGlomeruli();
                document.getElementById('ai-strategy').textContent = this.agent.currentStrategy;
                document.getElementById('decisions').textContent = this.agent.decisions;
                
                // Mission
                const scoreEl = document.getElementById('score-display');
                if (scoreEl) {
                    scoreEl.textContent = this.agent.score.toLocaleString('en-US');
                }
                const highScoreEl = document.getElementById('high-score-display');
                if (highScoreEl) {
                    highScoreEl.textContent = this.agent.highScore.toLocaleString('en-US');
                }
                const deflectionsEl = document.getElementById('deflections');
                if (deflectionsEl) {
                    deflectionsEl.textContent = this.agent.deflections;
                }
                const earthHitsEl = document.getElementById('earth-hits');
                if (earthHitsEl) {
                    earthHitsEl.textContent = this.agent.earthHits;
                }
                const waveEl = document.getElementById('wave');
                if (waveEl) {
                    waveEl.textContent = this.agent.wave;
                }
                const comboEl = document.getElementById('combo');
                if (comboEl) {
                    comboEl.textContent = `${this.agent.comboMultiplier.toFixed(1)}√ó`;
                }
                const comboStreakEl = document.getElementById('combo-streak');
                if (comboStreakEl) {
                    comboStreakEl.textContent = this.agent.comboStreak;
                }
                const missionTimeEl = document.getElementById('mission-time');
                if (missionTimeEl) {
                    missionTimeEl.textContent = formatMissionTime(this.agent.missionTime);
                }
                
                // Swarm
                document.getElementById('sats-active').textContent = this.satellites.length;
                const headerSat = document.getElementById('header-sat-count');
                if (headerSat) {
                    headerSat.textContent = `${this.satellites.length} SATS`;
                }
                document.getElementById('power').textContent = Math.floor(this.swarmPower);
                const maxSatsEl = document.getElementById('max-sats');
                if (maxSatsEl) {
                    maxSatsEl.textContent = this.targetSatelliteCount;
                }
                const targetEl = document.getElementById('swarm-target');
                if (targetEl) {
                    targetEl.textContent = this.targetSatelliteCount;
                }
                const powerMultiplierEl = document.getElementById('power-multiplier');
                if (powerMultiplierEl) {
                    powerMultiplierEl.textContent = this.powerMultiplier.toFixed(1) + '√ó';
                }
                const timeScaleEl = document.getElementById('time-scale');
                if (timeScaleEl) {
                    timeScaleEl.textContent = this.timeScale.toFixed(1) + '√ó';
                }
                const timeSlider = document.getElementById('time-slider');
                if (timeSlider) {
                    timeSlider.value = this.timeScale.toFixed(1);
                }
                const massScaleEl = document.getElementById('asteroid-mass-scale');
                if (massScaleEl) {
                    massScaleEl.textContent = this.asteroidMassScale.toFixed(1) + '√ó';
                }
                const massSlider = document.getElementById('mass-slider');
                if (massSlider) {
                    massSlider.value = this.asteroidMassScale.toFixed(1);
                }

                const coherence = this.convergence > 50 ? 100 : Math.floor(this.convergence * 2);
                document.getElementById('coherence').textContent = coherence;

                const formation = this.currentTarget ? 'FOCUS' : 'SPHERE';
                document.getElementById('formation').textContent = formation;

                // Mirrors
                const totalPower = this.getTotalPowerMW();
                document.getElementById('total-power').textContent = totalPower.toFixed(0);
                const gpuStatus = document.getElementById('gpu-status');
                if (gpuStatus) {
                    gpuStatus.textContent = totalPower.toFixed(0) + ' MW';
                }
                const powerPerSat = document.getElementById('power-per-sat');
                if (powerPerSat) {
                    powerPerSat.textContent = (this.basePowerPerSatelliteMW * this.powerMultiplier).toFixed(1);
                }
                document.getElementById('focus-quality').textContent = this.focusQuality.toFixed(2);
                document.getElementById('convergence').textContent = Math.floor(this.convergence);
                const intensityMW = this.intensity / 1e6; // Convert W to MW
                document.getElementById('intensity').textContent = intensityMW.toFixed(2);
                const ablationRateDisplay = this.ablationRate >= 1000
                    ? this.ablationRate.toLocaleString(undefined, { maximumFractionDigits: 0 })
                    : this.ablationRate.toFixed(3);
                document.getElementById('ablation-rate').textContent = ablationRateDisplay;
                
                // Targets
                document.getElementById('asteroid-count').textContent = this.asteroids.length;
                if (this.currentTarget && this.currentTarget.userData) {
                    document.getElementById('locked-target').textContent = 'LOCKED';
                    const dist = this.currentTarget.position.length();
                    const distAU = dist / 150000; // Convert to AU
                    document.getElementById('target-distance').textContent = distAU.toFixed(2) + ' AU';
                    const vel = this.currentTarget.userData.velocity.length();
                    document.getElementById('target-velocity').textContent = vel.toFixed(1) + ' km/s';

                    const appliedDV = this.currentTarget.userData.ablationDV.length() * 1000;
                    const requiredDV = this.calculateRequiredDeltaV(this.currentTarget);
                    document.getElementById('delta-v').textContent = `${appliedDV.toFixed(1)} / ${requiredDV.toFixed(1)} m/s`;

                    const timeToImpact = vel > 0 ? dist / vel : 999;
                    const timeHours = timeToImpact / 3600; // Convert to hours
                    if (timeHours > 24) {
                        document.getElementById('impact-eta').textContent = (timeHours / 24).toFixed(1) + ' days';
                    } else {
                        document.getElementById('impact-eta').textContent = timeHours.toFixed(1) + ' hrs';
                    }
                } else {
                    document.getElementById('locked-target').textContent = 'NONE';
                    document.getElementById('target-distance').textContent = '--';
                    document.getElementById('target-velocity').textContent = '--';
                    document.getElementById('delta-v').textContent = '--';
                    document.getElementById('impact-eta').textContent = '--';
                }
                
                // Memory
                document.getElementById('mem-danger').textContent = this.agent.threatMap.size;
                document.getElementById('mem-visited').textContent = this.agent.trajectoryMemory.size;
                document.getElementById('mem-boundaries').textContent = this.agent.optimalPositions.size;
                
                // Physics
                const photonFlux = this.convergence > 30 ? (this.convergence / 100).toFixed(2) : '0.0';
                document.getElementById('photon-flux').textContent = photonFlux;

                const ejectaDV = this.currentTarget && this.currentTarget.userData ?
                    (this.currentTarget.userData.ablationDV.length() * 1000).toFixed(1) : '0.0';
                document.getElementById('ejecta-dv').textContent = ejectaDV;

                const energyEJ = this.modifiedEnergy ? this.modifiedEnergy / 1e18 : 0;
                document.getElementById('modified-energy').textContent = energyEJ.toFixed(3);

                const spallRate = this.intensity > 0.1 ? (this.intensity * 5).toFixed(1) : '0.0';
                document.getElementById('spall-rate').textContent = spallRate;
            }
            
            onResize() {
                this.camera.aspect = (window.innerWidth - 380) / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth - 380, window.innerHeight);
            }
        }
        
        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        const space = new SpaceScene();

        const satelliteSlider = document.getElementById('satellite-slider');
        if (satelliteSlider) {
            satelliteSlider.addEventListener('input', (event) => {
                const value = parseInt(event.target.value, 10);
                if (!Number.isNaN(value)) {
                    space.setTargetSatelliteCount(value);
                }
            });
        }

        const powerSlider = document.getElementById('power-slider');
        if (powerSlider) {
            powerSlider.addEventListener('input', (event) => {
                const value = parseFloat(event.target.value);
                if (!Number.isNaN(value)) {
                    space.setPowerMultiplier(value);
                }
            });
        }

        const timeSlider = document.getElementById('time-slider');
        if (timeSlider) {
            timeSlider.addEventListener('input', (event) => {
                const value = parseFloat(event.target.value);
                if (!Number.isNaN(value)) {
                    space.setTimeScale(value);
                }
            });
        }

        const massSlider = document.getElementById('mass-slider');
        if (massSlider) {
            massSlider.addEventListener('input', (event) => {
                const value = parseFloat(event.target.value);
                if (!Number.isNaN(value)) {
                    space.setAsteroidMassScale(value);
                }
            });
        }

        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üõ∞Ô∏è  SWARM DEFENSE v2.1 - SURGICAL FIXES APPLIED');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('');
        console.log(`üõ∞Ô∏è  CONSTELLATION: ${space.satellites.length} Satellites (with movement AI)`);
        console.log('   ‚Ä¢ Fibonacci sphere distribution');
        console.log('   ‚Ä¢ 8000 km orbital radius');
        console.log('   ‚Ä¢ Auto-repositioning for optimal convergence');
        console.log('');
        console.log('ü™ô GOLD PARABOLIC MIRRORS (Edge of Possible):');
        console.log('   ‚Ä¢ Area: 1,000 m¬≤ per satellite');
        console.log('   ‚Ä¢ Reflectivity: 95% (gold coating)');
        console.log('   ‚Ä¢ Concentration: 85% (parabolic focus)');
        console.log(`   ‚Ä¢ Power per sat: ${(space.basePowerPerSatelliteMW * space.powerMultiplier).toFixed(1)} MW`);
        console.log(`   ‚Ä¢ TOTAL POWER: ${(space.getTotalPowerMW()).toFixed(0)} MW`);
        console.log('');
        console.log('üìê CARBONACEOUS CHONDRITE ABLATION:');
        console.log('   ‚Ä¢ Density: 2,200 kg/m¬≥');
        console.log('   ‚Ä¢ Vaporization: 4 MJ/kg');
        console.log('   ‚Ä¢ Ejecta velocity: 1,000 m/s');
        console.log('   ‚Ä¢ Mass ablation: ~13.75 kg/s (full power)');
        console.log(`   ‚Ä¢ Time warp: ${space.ablationTimeWarp.toLocaleString()}√ó dwell integration`);
        console.log('');
        console.log('üì° DETECTION & ENGAGEMENT:');
        console.log('   ‚Ä¢ Detection: 2 AU (300M km)');
        console.log('   ‚Ä¢ Engagement: 1 AU (150M km)');
        console.log('   ‚Ä¢ Lead time: Days to weeks');
        console.log('   ‚Ä¢ Asteroid velocity: 30-50 km/s (SLOWER for demo)');
        console.log('');
        console.log('üéØ DEFLECTION STRATEGY: PERPENDICULAR THRUST');
        console.log('   ‚Ä¢ NO head-on braking (inefficient!)');
        console.log('   ‚Ä¢ Lateral push for maximum miss distance');
        console.log('   ‚Ä¢ Early deflection = exponential payoff');
        console.log('');
        console.log('üî¨ WATCH FOR:');
        console.log('   ‚Ä¢ Yellow beams = solar concentration');
        console.log('   ‚Ä¢ Cyan arrow = thrust vector (perpendicular!)');
        console.log('   ‚Ä¢ RED line = ORIGINAL trajectory');
        console.log('   ‚Ä¢ GREEN line = SAFE modified trajectory');
        console.log('   ‚Ä¢ ORANGE line = DANGER modified trajectory');
        console.log('');
        console.log('‚ö° FIXES APPLIED:');
        console.log('   ‚Ä¢ GPU texture padding (no undefined reads)');
        console.log('   ‚Ä¢ WebGL2 VAO compatibility');
        console.log('   ‚Ä¢ Object pooling (beams, trajectories)');
        console.log('   ‚Ä¢ Fixed intensity calculation (real P_laser)');
        console.log('   ‚Ä¢ Merged duplicate focal point calcs');
        console.log('   ‚Ä¢ Satellite movement AI');
        console.log('   ‚Ä¢ Dual trajectory visualization');
        console.log('');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        function animate() {
            requestAnimationFrame(animate);
            space.update();
        }
        
        animate();

        console.log('üõ∞Ô∏è SWARM DEFENSE v2.1 - SURGICAL FIXES COMPLETE!');
        console.log(`‚ö° ${space.satellites.length} satellites √ó ${(space.basePowerPerSatelliteMW * space.powerMultiplier).toFixed(1)} MW = ${(space.getTotalPowerMW()).toFixed(0)} MW TOTAL POWER`);
        console.log('üì° Detection: 2 AU | Engagement: 1 AU');
        console.log('üéØ RED line = original path | GREEN = safe | ORANGE = danger');
        console.log('ü§ñ Satellites auto-position for optimal beam convergence');
        console.log('Controls: SPACE=Auto-engage, A=Toggle AI, T=Target, D=Deploy, R=Reset');
    </script>
</body>
</html>
